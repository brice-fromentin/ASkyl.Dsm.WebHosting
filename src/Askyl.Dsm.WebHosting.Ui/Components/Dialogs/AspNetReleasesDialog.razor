@using Askyl.Dsm.WebHosting.Tools.Runtime
@using Askyl.Dsm.WebHosting.Data.Runtime
@using Askyl.Dsm.WebHosting.Ui.Models
@using Askyl.Dsm.WebHosting.Ui.Services
@using System.Threading.Tasks

@implements IDialogContentComponent

@inject IDialogService DialogsService
@inject IFrameworkManagementService ManagementService
@inject IDotnetVersionService DotnetVersionService

<style>
    .selected-row {
        background-color: var(--accent-fill-rest) !important;
        color: var(--neutral-foreground-on-accent-rest) !important;
    }
    
    .selected-row:hover {
        background-color: var(--accent-fill-hover) !important;
        color: var(--neutral-foreground-on-accent-rest) !important;
    }
</style>

<FluentOverlay @bind-Visible="@IsInstalling" Opacity="0.7">
    @*<div style="display: flex; align-items: center; justify-content: center; height: 100%; width: 100%;">*@
        <FluentStack Orientation="Orientation.Vertical" HorizontalAlignment="HorizontalAlignment.Center" VerticalAlignment="VerticalAlignment.Center">
            <FluentProgressRing Size="FluentProgressSize.Large" />
            <FluentLabel Typo="Typography.Header">
                @(IsSelectedVersionInstalled ? "Uninstalling" : "Installing") ASP.NET Core @(SelectedItem?.Version ?? "")...
            </FluentLabel>
        </FluentStack>
    @*</div>*@
</FluentOverlay>

<FluentDialogHeader ShowDismiss="true">
    <FluentLabel Typo="Typography.H2">ASP.NET Online</FluentLabel>
</FluentDialogHeader>

<FluentDialogFooter>
    <FluentButton OnClick="CancelAsync" Appearance="Appearance.Accent" Style="flex-grow: 1;" Disabled="@IsInstalling">Close</FluentButton>
</FluentDialogFooter>

<FluentDialogBody>
    <FluentToolbar>
        <FluentLabel>Channel</FluentLabel>

        <FluentSelect TOption="String" @onchange="OnChannelChanged" Width="120px" Value="@SelectedChannel" Disabled="@IsInstalling">
            @if (Channels == null)
            {
                <FluentOption Value="">Loading...</FluentOption>
            }
            else
            {
                @foreach (var c in Channels)
                {
                    <FluentOption Value="@c.ProductVersion">@c.ProductVersion
                        @(c.IsLts ? "(LTS)" : String.Empty)
                    </FluentOption>
                }
            }
        </FluentSelect>

        <FluentButton OnClick="Refresh" Appearance="Appearance.Outline" Title="Refresh" Disabled="@IsInstalling">
            <FluentIcon Value="@(new IconsRegular16.ArrowClockwise())" />
        </FluentButton>

        <FluentButton OnClick="@(IsSelectedVersionInstalled ? UninstallSelectedFramework : InstallSelectedFramework)" Appearance="Appearance.Accent" Disabled="@(!CanProcessSelected || IsInstalling)" Title="@GetActionButtonTooltip()" Style="flex-grow: 1; ">
            <FluentStack Orientation="Orientation.Horizontal" VerticalAlignment="VerticalAlignment.Center">
                <FluentIcon Value="@(IsSelectedVersionInstalled ? (Icon)new IconsRegular16.Delete() : new IconsRegular16.CloudArrowDown())" Color="Color.Fill" />
                <FluentLabel Color="Color.Fill" Style="margin-left: 4px;">
                    @GetActionButtonText()
                </FluentLabel>
            </FluentStack>
        </FluentButton>
    </FluentToolbar>

    <div style="width: 650px; height: 364px;">
        <FluentDataGrid @ref="@Grid" TItem="ReleaseGridRow" ItemsProvider="@rowsProvider" DisplayMode="DataGridDisplayMode.Grid" Pagination="@pagination" ShowHover="true" OnRowClick="@(EventCallback.Factory.Create<FluentDataGridRow<ReleaseGridRow>>(this, OnRowClick))" RowClass="@GetRowClass">

            <ChildContent>
                <PropertyColumn Title="Version" Property="@(r => r.Version)" Width="240px" />
                <PropertyColumn Title="Latest" Property="@(r => r.Latest)" Align="Align.Center" Width="90px" />
                <PropertyColumn Title="Security" Property="@(r => r.Security)" Align="Align.Center" Width="100px" />
                <PropertyColumn Title="Installed" Property="@(r => r.Installed)" Align="Align.Center" Width="100px" />
                <PropertyColumn Title="Release" Property="@(r => r.ReleaseDate)" Width="120px" />
            </ChildContent>

            <LoadingContent>
                <FluentStack Orientation="Orientation.Vertical" HorizontalAlignment="HorizontalAlignment.Center" Width="650px">
                    Loading...<br />
                    <FluentProgress Width="50%" />
                </FluentStack>
            </LoadingContent>
        </FluentDataGrid>
    </div>

    <FluentPaginator State="@pagination" />
</FluentDialogBody>

@code
{
    [CascadingParameter]
    public FluentDialog Dialog { get; set; } = default!;

    private FluentDataGrid<ReleaseGridRow>? Grid { get; set; }
    private readonly PaginationState pagination = new() { ItemsPerPage = 10 };
    private GridItemsProvider<ReleaseGridRow> rowsProvider = default!;

    private List<Downloader.AspNetCoreReleaseInfo>? Releases { get; set; }
    private List<Downloader.AspNetCoreChannelInfo>? Channels { get; set; }
    private string? SelectedChannel { get; set; }
    private bool IsInstalling { get; set; } = false;
    private ReleaseGridRow? SelectedItem { get; set; }

    private bool IsSelectedVersionInstalled => SelectedItem?.Installed.Equals("✓") == true;

    private bool CanProcessSelected
    {
        get
        {
            return !IsInstalling && SelectedItem != null;
        }
    }

    private bool CanInstallSelected
    {
        get
        {
            return !IsInstalling &&
            SelectedItem != null &&
            !SelectedItem.Installed.Equals("✓");
        }
    }

    private IEnumerable<ReleaseGridRow> GetSelectedItems()
    {
        return SelectedItem != null ? new[] { SelectedItem } : Enumerable.Empty<ReleaseGridRow>();
    }

    private void OnRowClick(FluentDataGridRow<ReleaseGridRow> row)
    {
        SelectedItem = row.Item;
        StateHasChanged();
    }

    private string GetRowClass(ReleaseGridRow row)
    {
        return SelectedItem != null && SelectedItem.Version == row.Version ? "selected-row" : String.Empty;
    }

    private string GetActionButtonText()
    {
        if (SelectedItem == null)
        {
            return "Select a version";
        }

        return IsSelectedVersionInstalled 
            ? $"Uninstall {SelectedItem.Version}" 
            : $"Install {SelectedItem.Version}";
    }

    private string GetActionButtonTooltip()
    {
        if (IsInstalling)
        {
            return IsSelectedVersionInstalled ? "Uninstallation in progress..." : "Installation in progress...";
        }

        if (SelectedItem == null)
        {
            return "Select a framework version";
        }

        return IsSelectedVersionInstalled 
            ? $"Uninstall ASP.NET Core {SelectedItem.Version}" 
            : $"Install ASP.NET Core {SelectedItem.Version}";
    }

    private string GetInstallButtonTooltip()
    {
        if (IsInstalling)
        {
            return "Installation in progress...";
        }

        if (SelectedItem == null)
        {
            return "Select a framework version to install";
        }

        if (SelectedItem.Installed.Equals("✓"))
        {
            return $"Version {SelectedItem.Version} is already installed";
        }

        return $"Install ASP.NET Core {SelectedItem.Version}";
    }

    protected override async Task OnParametersSetAsync()
    {
        rowsProvider = new(LoadRowsAsync);
        await LoadChannelsAsync();
        // Preload the cache for version detection
        await DotnetVersionService.GetInstalledVersionsAsync();
    }

    private async Task CancelAsync()
    {
        await Dialog.CancelAsync();
    }

    private async Task ShowErrorAsync(string error)
    {
        await DialogsService.ShowErrorAsync(error);
    }

    private async Task LoadChannelsAsync()
    {
        try
        {
            var channels = await Downloader.GetAspNetCoreChannelsAsync();
            Channels = channels.ToList();

            if (String.IsNullOrWhiteSpace(SelectedChannel))
            {
                SelectedChannel = Channels.FirstOrDefault()?.ProductVersion;

                if (!String.IsNullOrWhiteSpace(SelectedChannel))
                {
                    await OnChannelChanged(new ChangeEventArgs { Value = SelectedChannel });
                }
            }
        }
        catch (Exception ex)
        {
            await ShowErrorAsync(ex.Message);
            Channels = null;
            SelectedChannel = null;
            Releases = null;
        }
    }

    private async ValueTask<GridItemsProviderResult<ReleaseGridRow>> LoadRowsAsync(GridItemsProviderRequest<ReleaseGridRow> request)
    {
        if (String.IsNullOrWhiteSpace(SelectedChannel))
        {
            return GridItemsProviderResult.From<ReleaseGridRow>(Array.Empty<ReleaseGridRow>(), 0);
        }

        // Load releases if not already loaded
        if (Releases == null)
        {
            try
            {
                var list = await Downloader.GetAspNetCoreReleasesAsync(SelectedChannel);
                Releases = list.ToList();
            }
            catch (Exception ex)
            {
                await ShowErrorAsync(ex.Message);
                return GridItemsProviderResult.From<ReleaseGridRow>(Array.Empty<ReleaseGridRow>(), 0);
            }
        }

        if (Releases == null || Releases.Count == 0)
        {
            return GridItemsProviderResult.From<ReleaseGridRow>(Array.Empty<ReleaseGridRow>(), 0);
        }

        var startIndex = request.StartIndex;
        var count = Math.Min(request.Count ?? Releases.Count, Releases.Count - startIndex);
        var pagedReleases = Releases.Skip(startIndex).Take(count);

        // Check which versions are installed locally
        var pagedItems = new List<ReleaseGridRow>();
        foreach (var release in pagedReleases)
        {
            var isInstalled = await DotnetVersionService.IsVersionInstalledAsync(release.Version, "ASP.NET Core");
            pagedItems.Add(ReleaseGridRow.Create(release, isInstalled));
        }

        return GridItemsProviderResult.From<ReleaseGridRow>(pagedItems, Releases.Count);
    }

    private async Task OnChannelChanged(ChangeEventArgs e)
    {
        SelectedChannel = e.Value?.ToString();
        await Refresh();
    }

    private async Task Refresh()
    {
        Releases = null;
        SelectedItem = null;

        if (Grid != null)
        {
            Grid.SetLoadingState(true);
            await Grid.RefreshDataAsync();
            Grid.SetLoadingState(false);
        }
    }

    private async Task InstallSelectedFramework()
    {
        if (!CanInstallSelected || SelectedItem == null)
        {
            return;
        }

        IsInstalling = true;
        StateHasChanged();

        try
        {
            var result = await ManagementService.InstallFrameworkAsync(SelectedItem.Version, SelectedChannel ?? String.Empty);

            if (result.Success)
            {
                await DialogsService.ShowInfoAsync(result.Message);
                await Refresh(); // Refresh to update the installed status
            }
            else
            {
                await DialogsService.ShowErrorAsync(result.Message);
            }
        }
        catch (Exception ex)
        {
            await DialogsService.ShowErrorAsync($"Installation error: {ex.Message}");
        }
        finally
        {
            IsInstalling = false;
            StateHasChanged();
        }
    }

    private async Task UninstallSelectedFramework()
    {
        if (!IsSelectedVersionInstalled || SelectedItem == null)
        {
            return;
        }

        var confirmationMessage = $"Click OK if you want to proceed with uninstalling ASP.NET Core {SelectedItem.Version}";
        var confirmation = await DialogsService.ShowConfirmationAsync(confirmationMessage);
        var result = await confirmation.Result;

        if (result == null || result.Cancelled)
        {
            return;
        }
        
        IsInstalling = true;
        StateHasChanged();

        try
        {
            var uninstallResult = await ManagementService.UninstallFrameworkAsync(SelectedItem.Version);

            if (uninstallResult.Success)
            {
                await DialogsService.ShowInfoAsync(uninstallResult.Message);
                await Refresh();
            }
            else
            {
                await DialogsService.ShowErrorAsync(uninstallResult.Message);
            }
        }
        catch (Exception ex)
        {
            await DialogsService.ShowErrorAsync($"Uninstallation error: {ex.Message}");
        }
        finally
        {
            IsInstalling = false;
            StateHasChanged();
        }
    }
}
