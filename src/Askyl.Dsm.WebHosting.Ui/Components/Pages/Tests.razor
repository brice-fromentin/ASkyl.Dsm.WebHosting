@page "/tests"

@using Askyl.Dsm.WebHosting.Data.API.Definitions.ReverseProxy
@using Askyl.Dsm.WebHosting.Data.API.Definitions.Core
@using Askyl.Dsm.WebHosting.Data.API.Definitions.FileStation
@using System.Text.Json
@using Askyl.Dsm.WebHosting.Constants
@using Askyl.Dsm.WebHosting.Data.API.Parameters
@using Askyl.Dsm.WebHosting.Constants.Application
@using Askyl.Dsm.WebHosting.Data.API.Parameters.ReverseProxyAPI
@using Askyl.Dsm.WebHosting.Data.API.Responses
@using Askyl.Dsm.WebHosting.Tools.Network
@using Askyl.Dsm.WebHosting.Ui.Components.Patterns.WorkingState

@implements IWorkingState

@inject IDialogService DialogsService
@inject DsmApiClient client
@inject NavigationManager navigation
@inject ILogDownloadService logDownloadService
@inject ITemporaryTokenService tokenService

<PageTitle>ADWH - Tests</PageTitle>

<LoadingOverlay WorkingStateComponent="@this" />

<FluentToolbar Class="full-width">
    <FluentButton OnClick="CallReverseList">List Proxies</FluentButton>
    <FluentButton OnClick="CallReverseCreate">Create</FluentButton>
    <FluentButton OnClick="CallReverseUpdate">Update</FluentButton>
    <FluentTextField @bind-Value="Uuid" autofocus />
    <FluentButton OnClick="CallReverseDelete">Delete</FluentButton>
    <FluentSpacer />
    <FluentButton OnClick="ShowDotnetVersionsDialog" Appearance="Appearance.Outline">
        .NET Version
    </FluentButton>
    <FluentButton OnClick="ShowAspNetReleasesDialog" Appearance="Appearance.Outline">
        ASP.NET Online
    </FluentButton>
    <FluentButton OnClick="ShowFileSelectionDialog" Appearance="Appearance.Outline">
        Select File
    </FluentButton>
    <FluentButton OnClick="DownloadLogs" Appearance="Appearance.Outline">
        Download Logs
    </FluentButton>
</FluentToolbar>
<br />

<h2>Existing reverse proxies</h2>
<div>
    @if (proxies is not null)
    {
        foreach (var proxy in proxies)
        {
            <div>@JsonSerializer.Serialize(proxy)</div>
            <br />
        }
    }
</div>


@code
{
    private List<ReverseProxy>? proxies { get; set; }
    private string? Uuid { get; set; }

    #region IWorkingState Implementation

    public bool IsWorking { get; set; }
    public string Message { get; set; } = "";

    public void NotifyStateChanged() => StateHasChanged();

    #endregion

    protected override async Task OnInitializedAsync()
    {
        if (!client.IsConnected)
        {
            navigation.NavigateTo("/login");
            return;
        }

        await CallReverseList();
    }

    private async Task CallReverseList()
    {
        var parameters = new ReverseProxyListParameters(client.ApiInformations);
        var list = await client.ExecuteAsync<ReverseProxyListResponse>(parameters);
        proxies = list?.Data?.Entries;
    }

    private async Task CallReverseCreate()
    {
        var parameters = new ReverseProxyCreateParameters(client.ApiInformations);
        var entry = parameters.Parameters;

        entry.Description = "test-name";
        entry.Frontend = new() { Fqdn = "test-hostname", Port = 80, Protocol = 0 };
        entry.Backend = new() { Fqdn = "test-target-name", Port = 80, Protocol = 0 };

        await CallAPI(parameters);
    }

    private async Task CallReverseUpdate()
    {
        if (proxies is null || proxies.Count == 0)
        {
            await DialogsService.ShowErrorAsync($"No proxy available.");
            return;
        }

        var originalProxy = proxies.First();
        var parameters = new ReverseProxyUpdateParameters(client.ApiInformations, originalProxy);

        // Manually copy properties from originalProxy to the new Parameters object
        var entry = parameters.Parameters;
        entry.UUID = originalProxy.UUID;
        entry.Description = originalProxy.Description + "-updated"; // The only change
        entry.Frontend = originalProxy.Frontend;
        entry.Backend = originalProxy.Backend;
        entry.ProxyConnectTimeout = originalProxy.ProxyConnectTimeout;
        entry.ProxyHttpVersion = originalProxy.ProxyHttpVersion;
        entry.ProxyInterceptErrors = originalProxy.ProxyInterceptErrors;
        entry.ProxyReadTimeout = originalProxy.ProxyReadTimeout;
        entry.ProxySendTimeout = originalProxy.ProxySendTimeout;
        entry.CustomizeHeaders = originalProxy.CustomizeHeaders;
        entry.Key = originalProxy.Key;

        await CallAPI(parameters);
    }

    private async Task CallReverseDelete()
    {
        if (String.IsNullOrWhiteSpace(Uuid) || !Guid.TryParse(Uuid, out var id))
        {
            await DialogsService.ShowErrorAsync($"Invalid UUID.");
            return;
        }

        var parameters = new ReverseProxyDeleteParameters(client.ApiInformations);
        parameters.Parameters.Add(id);

        if (await CallAPI(parameters))
        {
            Uuid = "";
        }
    }

    private async Task<bool> CallAPI(IApiParameters parameters)
    {
        if (IsWorking)
        {
            return false;
        }

        using var worker = this.CreateWorkingState("Processing API request...");

        try
        {
            var response = await client.ExecuteAsync<ApiGenericResponse>(parameters);

            if (response == null || !response.Success)
            {
                await DialogsService.ShowErrorAsync($"Code = {response?.Error?.Code}, Reason = {response?.Error?.Errors?.Reason}, Index = [{String.Join(", ", response?.Error?.Errors?.Index ?? [])}]");
                return false;
            }

            await CallReverseList();
            return true;
        }
        catch (Exception ex)
        {
            await DialogsService.ShowErrorAsync($"Error during API call: {ex.Message}");
            return false;
        }
    }

    private async Task ShowDotnetVersionsDialog()
    => await DialogsService.ShowDialogAsync<DotnetVersionsDialog>(new() { Width = "", Height = "", Modal = true });

    private async Task ShowAspNetReleasesDialog()
    => await DialogsService.ShowDialogAsync<AspNetReleasesDialog>(new() { Width = "", Height = "", Modal = true });

    private async Task ShowFileSelectionDialog()
    {
        var dialog = await DialogsService.ShowDialogAsync<FileSelectionDialog>(new() { Width = "80%", Height = "80%", Modal = true, });
        var result = await dialog.Result;

        if (result.Cancelled || result.Data == null)
        {
            return;
        }

        // Handle the selected file
        var selectedFile = result.Data as FileStationFile;
        if (selectedFile != null)
        {
            await DialogsService.ShowInfoAsync($"Selected file: {selectedFile.Name}\nPath: {selectedFile.Path}");
        }
    }

    private async Task DownloadLogs()
    {
        try
        {
            // Generate temporary token for authentication
            var token = tokenService.GenerateToken();

            if (String.IsNullOrEmpty(token))
            {
                await DialogsService.ShowErrorAsync("Authentication required. Please make sure you are connected to DSM.");
                return;
            }

            // Direct navigation to trigger download (no popup)
            var downloadUrl = $"{LogConstants.LogDownloadEndpoint}?{LogConstants.TokenQueryParameter}={Uri.EscapeDataString(token)}";
            navigation.NavigateTo(downloadUrl, forceLoad: true);
        }
        catch (Exception ex)
        {
            await DialogsService.ShowErrorAsync($"Error downloading logs: {ex.Message}");
        }
    }
}