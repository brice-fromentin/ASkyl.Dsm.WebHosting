using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Askyl.Dsm.WebHosting.SourceGenerators;

[Generator]
public class CloneGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Generate the attribute once for the assembly
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "GenerateCloneAttribute.g.cs",
            SourceText.From(@"// <auto-generated/>
namespace Askyl.Dsm.WebHosting.SourceGenerators
{
    [System.AttributeUsage(System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    internal sealed class GenerateCloneAttribute : System.Attribute
    {
    }
}
", Encoding.UTF8)));

        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        context.RegisterSourceOutput(classDeclarations, static (spc, source) => Execute(source!, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDeclaration &&
               classDeclaration.AttributeLists.Count > 0;
    }

    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        foreach (var attributeList in classDeclaration.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                var attributeSymbol = context.SemanticModel.GetSymbolInfo(attribute).Symbol;
                if (attributeSymbol is IMethodSymbol attributeConstructor)
                {
                    var attributeType = attributeConstructor.ContainingType;
                    if (attributeType.Name == "GenerateCloneAttribute")
                    {
                        return classDeclaration;
                    }
                }
            }
        }

        return null;
    }

    private static void Execute(ClassDeclarationSyntax classDeclaration, SourceProductionContext context)
    {
        var namespaceName = GetNamespace(classDeclaration);
        var className = classDeclaration.Identifier.Text;

        var properties = classDeclaration.Members
            .OfType<PropertyDeclarationSyntax>()
            .Where(p => p.AccessorList?.Accessors.Any(a => a.IsKind(SyntaxKind.SetAccessorDeclaration) || a.IsKind(SyntaxKind.InitAccessorDeclaration)) == true)
            .ToList();

        var source = GenerateCloneMethod(namespaceName, className, properties, classDeclaration);

        context.AddSource($"{className}.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string GetNamespace(ClassDeclarationSyntax classDeclaration)
    {
        var namespaceDeclaration = classDeclaration.Ancestors().OfType<BaseNamespaceDeclarationSyntax>().FirstOrDefault();
        return namespaceDeclaration?.Name.ToString() ?? String.Empty;
    }

    private static string GenerateCloneMethod(string namespaceName, string className, List<PropertyDeclarationSyntax> properties, ClassDeclarationSyntax classDeclaration)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine($"public partial class {className} : IGenericCloneable<{className}>");
        sb.AppendLine("{");
        sb.AppendLine($"    public {className} Clone()");
        sb.AppendLine("        => new()");
        sb.AppendLine("        {");

        foreach (var property in properties)
        {
            var propertyName = property.Identifier.Text;
            var propertyType = property.Type.ToString();

            if (IsCloneableType(propertyType))
            {
                sb.AppendLine($"            {propertyName} = this.{propertyName}.Clone(),");
            }
            else if (IsListType(propertyType))
            {
                var elementType = GetListElementType(propertyType);
                if (IsCloneableType(elementType))
                {
                    sb.AppendLine($"            {propertyName} = [.. this.{propertyName}.Select(item => item.Clone())],");
                }
                else
                {
                    sb.AppendLine($"            {propertyName} = [.. this.{propertyName}],");
                }
            }
            else
            {
                sb.AppendLine($"            {propertyName} = this.{propertyName},");
            }
        }

        sb.AppendLine("        };");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static bool IsCloneableType(string typeName)
        => typeName.Contains("IGenericCloneable");

    private static bool IsListType(string typeName)
        => typeName.StartsWith("List<") || typeName.StartsWith("IList<") || typeName.StartsWith("IEnumerable<");

    private static string GetListElementType(string listType)
    {
        var start = listType.IndexOf('<') + 1;
        var end = listType.LastIndexOf('>');
        return listType.Substring(start, end - start);
    }
}
